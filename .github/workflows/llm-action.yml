name: AI Code Review

on:
  pull_request_target:
    types: [labeled]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR head refs
        run: |
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-head

      - name: Get PR diff
        run: |
          git diff origin/${{ github.base_ref }}...pr-head > pr.diff
          echo "DIFF_FILE=$PWD/pr.diff" >> $GITHUB_ENV

      - name: AI Code Review
        id: review
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const fs = require('node:fs');
            const diffFile = process.env.DIFF_FILE;
            const apiKey = process.env.GEMINI_API_KEY;

            if (!apiKey) {
              core.setFailed('GEMINI_API_KEY secret is missing.');
              return;
            }

            if (!diffFile || !fs.existsSync(diffFile)) {
              core.setFailed(`Diff file is missing: ${diffFile || 'undefined'}`);
              return;
            }

            const SINGLE_CHUNK_LIMIT = 60_000;
            const CHUNK_CHAR_LIMIT = 30_000;

            let diff = fs.readFileSync(diffFile, 'utf8').trim();
            if (!diff) {
              core.setFailed('Diff is empty. Add code changes before requesting AI review.');
              return;
            }

            const systemPrompt = [
              'ä½ æ˜¯ä¸€ä½è³‡æ·±çš„ç¨‹å¼ç¢¼å¯©æŸ¥å°ˆå®¶ï¼Œè«‹æ ¹æ“šä»¥ä¸‹æ¨™æº–å¯©æŸ¥ç¨‹å¼ç¢¼ï¼š',
              '1. ç¨‹å¼ç¢¼å“è³ªèˆ‡å¯è®€æ€§',
              '2. æ½›åœ¨çš„ Bug æˆ–å®‰å…¨æ¼æ´',
              '3. æ•ˆèƒ½å•é¡Œ',
              '4. æœ€ä½³å¯¦è¸å»ºè­°',
              '5. å›å‚³çµæœæ™‚å¿…é ˆåš´æ ¼ç¬¦åˆ JSON schemaï¼Œä¸”ä¸è¦åŒ…å«ä»»ä½•å¤šé¤˜æ–‡å­—ã€‚'
            ].join('\n');

            const responseSchema = {
              type: 'object',
              properties: {
                score: { type: 'string' },
                summary: { type: 'string' },
                issues: { type: 'string' },
                suggestions: { type: 'string' },
                approved: { type: 'string' }
              },
              required: ['score', 'summary', 'issues', 'suggestions', 'approved']
            };

            function chunkDiff(text, chunkSize) {
              const chunks = [];
              for (let i = 0; i < text.length; i += chunkSize) {
                chunks.push(text.slice(i, i + chunkSize));
              }
              return chunks;
            }

            async function reviewChunk(chunkText, chunkIndex, totalChunks) {
              const chunkLabel =
                totalChunks > 1 ? `ï¼ˆç¬¬ ${chunkIndex + 1}/${totalChunks} éƒ¨åˆ†ï¼‰` : '';
              const userPrompt = [
                `ä»¥ä¸‹æ˜¯ Pull Request çš„ diff${chunkLabel}ï¼š`,
                '',
                chunkText
              ].join('\n');

              const payload = {
                systemInstruction: {
                  role: 'system',
                  parts: [{ text: systemPrompt }]
                },
                contents: [
                  {
                    role: 'user',
                    parts: [{ text: userPrompt }]
                  }
                ],
                generationConfig: {
                  temperature: 0.2,
                  responseMimeType: 'application/json',
                  responseSchema,
                  maxOutputTokens: 3072
                }
              };

              const response = await fetch(
                `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`,
                {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify(payload)
                }
              );

              if (!response.ok) {
                const errorText = await response.text();
                core.setFailed(
                  `Gemini API error for chunk ${chunkIndex + 1}/${totalChunks}: ` +
                    `${response.status} ${response.statusText} - ${errorText}`
                );
                return null;
              }

              const data = await response.json();
              const candidate = data?.candidates?.[0];
              const finishReason = candidate?.finishReason;
              const content = candidate?.content?.parts
                ?.map((part) => part.text ?? '')
                .join('')
                .trim();

              if (!content) {
                const promptTokens = data?.usageMetadata?.promptTokenCount;
                const totalTokens = data?.usageMetadata?.totalTokenCount;
                if (finishReason === 'MAX_TOKENS') {
                  core.setFailed(
                    `Gemini API hit the max token limit on chunk ${chunkIndex + 1}/${totalChunks} ` +
                      `(prompt tokens: ${promptTokens}, total tokens: ${totalTokens}). ` +
                      'Try reducing the diff size or rerunning the workflow.'
                  );
                } else {
                  core.setFailed(
                    `Gemini API returned an empty response on chunk ${chunkIndex + 1}/${totalChunks}: ` +
                      `${JSON.stringify(data)}`
                  );
                }
                return null;
              }

              let parsed;
              try {
                parsed = JSON.parse(content);
              } catch (error) {
                core.setFailed(
                  `Model response was not valid JSON on chunk ${chunkIndex + 1}/${totalChunks}: ${content}`
                );
                return null;
              }

              return parsed;
            }

            function gatherChunks(text) {
              if (text.length <= SINGLE_CHUNK_LIMIT) {
                return [text];
              }
              core.info(
                `Diff length ${text.length} chars exceeds ${SINGLE_CHUNK_LIMIT}. ` +
                  `Splitting into ${CHUNK_CHAR_LIMIT}-char chunks for review.`
              );
              return chunkDiff(text, CHUNK_CHAR_LIMIT);
            }

            function extractNumericScore(scoreStr) {
              if (typeof scoreStr !== 'string') return null;
              const match = scoreStr.match(/\\d+(?:\\.\\d+)?/);
              return match ? Number(match[0]) : null;
            }

            const diffChunks = gatherChunks(diff);
            const chunkResults = [];

            for (let i = 0; i < diffChunks.length; i++) {
              const parsed = await reviewChunk(diffChunks[i], i, diffChunks.length);
              if (!parsed) {
                return;
              }
              chunkResults.push(parsed);
            }

            const summaries = [];
            const issues = [];
            const suggestions = [];
            const numericScores = [];
            let approved = 'yes';

            chunkResults.forEach((result, index) => {
              const label = chunkResults.length > 1 ? `ç¬¬ ${index + 1} éƒ¨åˆ†ï¼š` : '';
              const summary = result.summary ? `${label}${result.summary}` : '';
              const issue = result.issues ? `${label}${result.issues}` : '';
              const suggestion = result.suggestions ? `${label}${result.suggestions}` : '';
              if (summary) summaries.push(summary);
              if (issue) issues.push(issue);
              if (suggestion) suggestions.push(suggestion);

              const numericScore = extractNumericScore(result.score);
              if (Number.isFinite(numericScore)) {
                numericScores.push(numericScore);
              }

              const approvedValue = (result.approved || '').trim().toLowerCase();
              if (approvedValue !== 'yes') {
                approved = 'no';
              }
            });

            const finalScore = numericScores.length
              ? (numericScores.reduce((sum, value) => sum + value, 0) / numericScores.length)
                  .toFixed(1)
                  .replace(/\\.0$/, '')
              : chunkResults[0]?.score || 'N/A';

            const finalSummary = summaries.join('\\n\\n');
            const finalIssues = issues.join('\\n\\n');
            const finalSuggestions = suggestions.join('\\n\\n');

            core.setOutput('score', finalScore);
            core.setOutput('summary', finalSummary);
            core.setOutput('issues', finalIssues);
            core.setOutput('suggestions', finalSuggestions);
            core.setOutput('approved', approved);

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const score = '${{ steps.review.outputs.score }}' || 'N/A';
            const summary = '${{ steps.review.outputs.summary }}';
            const issues = '${{ steps.review.outputs.issues }}';
            const suggestions = '${{ steps.review.outputs.suggestions }}';
            const approved = '${{ steps.review.outputs.approved }}';

            const emoji = approved === 'yes' ? 'âœ…' : 'âš ï¸';

            const body = `## ${emoji} AI Code Review çµæœ

            **è©•åˆ†ï¼š** ${score}/10

            **æ‘˜è¦ï¼š** ${summary}

            ### ğŸ” ç™¼ç¾çš„å•é¡Œ
            ${issues || 'ç„¡'}

            ### ğŸ’¡ æ”¹å–„å»ºè­°
            ${suggestions || 'ç„¡'}

            ---
            *æ­¤å¯©æŸ¥ç”± AI è‡ªå‹•ç”¢ç”Ÿï¼Œåƒ…ä¾›åƒè€ƒ*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Set review status
        if: steps.review.outputs.approved == 'no'
        run: |
          echo "::warning::AI å¯©æŸ¥å»ºè­°ï¼šæ­¤ PR éœ€è¦é€²ä¸€æ­¥ä¿®æ”¹"
          exit 1
