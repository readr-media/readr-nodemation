name: AI Code Review

on:
  pull_request_target:
    types: [labeled]

jobs:
  code-review:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR head refs
        run: |
          git fetch origin pull/${{ github.event.pull_request.number }}/head:pr-head

      - name: Get PR diff
        run: |
          git diff origin/${{ github.base_ref }}...pr-head > pr.diff
          echo "DIFF_FILE=$PWD/pr.diff" >> $GITHUB_ENV

      - name: AI Code Review
        id: review
        uses: actions/github-script@v7
        env:
          GEMINI_API_KEY: ${{ secrets.GEMINI_API_KEY }}
        with:
          script: |
            const fs = require('node:fs');
            const diffFile = process.env.DIFF_FILE;
            const apiKey = process.env.GEMINI_API_KEY;

            if (!apiKey) {
              core.setFailed('GEMINI_API_KEY secret is missing.');
              return;
            }

            if (!diffFile || !fs.existsSync(diffFile)) {
              core.setFailed(`Diff file is missing: ${diffFile || 'undefined'}`);
              return;
            }

            const diff = fs.readFileSync(diffFile, 'utf8').trim();
            if (!diff) {
              core.setFailed('Diff is empty. Add code changes before requesting AI review.');
              return;
            }

            const systemPrompt = [
              'ä½ æ˜¯ä¸€ä½è³‡æ·±çš„ç¨‹å¼ç¢¼å¯©æŸ¥å°ˆå®¶ï¼Œè«‹æ ¹æ“šä»¥ä¸‹æ¨™æº–å¯©æŸ¥ç¨‹å¼ç¢¼ï¼š',
              '1. ç¨‹å¼ç¢¼å“è³ªèˆ‡å¯è®€æ€§',
              '2. æ½›åœ¨çš„ Bug æˆ–å®‰å…¨æ¼æ´',
              '3. æ•ˆèƒ½å•é¡Œ',
              '4. æœ€ä½³å¯¦è¸å»ºè­°',
              '5. å›å‚³çµæœæ™‚å¿…é ˆåš´æ ¼ç¬¦åˆ JSON schemaï¼Œä¸”ä¸è¦åŒ…å«ä»»ä½•å¤šé¤˜æ–‡å­—ã€‚'
            ].join('\n');

            const userPrompt = [
              'ä»¥ä¸‹æ˜¯ Pull Request çš„ diffï¼š',
              '',
              diff
            ].join('\n');

            const responseSchema = {
              type: 'object',
              properties: {
                score: { type: 'string' },
                summary: { type: 'string' },
                issues: { type: 'string' },
                suggestions: { type: 'string' },
                approved: { type: 'string' }
              },
              required: ['score', 'summary', 'issues', 'suggestions', 'approved']
            };

            const payload = {
              systemInstruction: {
                role: 'system',
                parts: [{ text: systemPrompt }]
              },
              contents: [
                {
                  role: 'user',
                  parts: [{ text: userPrompt }]
                }
              ],
              generationConfig: {
                temperature: 0.2,
                responseMimeType: 'application/json',
                responseSchema,
                maxOutputTokens: 1024
              }
            };

            const response = await fetch(
              `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-pro:generateContent?key=${apiKey}`,
              {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
              }
            );

            if (!response.ok) {
              const errorText = await response.text();
              core.setFailed(`Gemini API error: ${response.status} ${response.statusText} - ${errorText}`);
              return;
            }

            const data = await response.json();
            const content = data?.candidates?.[0]?.content?.parts
              ?.map((part) => part.text ?? '')
              .join('')
              .trim();

            if (!content) {
              core.setFailed(`Gemini API returned an empty response: ${JSON.stringify(data)}`);
              return;
            }

            let parsed;
            try {
              parsed = JSON.parse(content);
            } catch (error) {
              core.setFailed(`Model response was not valid JSON: ${content}`);
              return;
            }

            const fields = ['score', 'summary', 'issues', 'suggestions', 'approved'];
            for (const field of fields) {
              const value = parsed[field] ?? '';
              core.setOutput(field, value);
            }

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const score = '${{ steps.review.outputs.score }}' || 'N/A';
            const summary = '${{ steps.review.outputs.summary }}';
            const issues = '${{ steps.review.outputs.issues }}';
            const suggestions = '${{ steps.review.outputs.suggestions }}';
            const approved = '${{ steps.review.outputs.approved }}';

            const emoji = approved === 'yes' ? 'âœ…' : 'âš ï¸';

            const body = `## ${emoji} AI Code Review çµæœ

            **è©•åˆ†ï¼š** ${score}/10

            **æ‘˜è¦ï¼š** ${summary}

            ### ğŸ” ç™¼ç¾çš„å•é¡Œ
            ${issues || 'ç„¡'}

            ### ğŸ’¡ æ”¹å–„å»ºè­°
            ${suggestions || 'ç„¡'}

            ---
            *æ­¤å¯©æŸ¥ç”± AI è‡ªå‹•ç”¢ç”Ÿï¼Œåƒ…ä¾›åƒè€ƒ*`;

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: body
            });

      - name: Set review status
        if: steps.review.outputs.approved == 'no'
        run: |
          echo "::warning::AI å¯©æŸ¥å»ºè­°ï¼šæ­¤ PR éœ€è¦é€²ä¸€æ­¥ä¿®æ”¹"
          exit 1
